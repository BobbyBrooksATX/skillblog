---
title: Using Leaflet in R - Tutorial
author: Timothy Lin
date: '2017-09-13'
slug: using-leaflet-in-r-tutorial
categories: []
tags: ["Singapore", "R", "spatial", "visualisation", "notes"]
subtitle: ''
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE, cache=FALSE)
```

Here's a tutorial on using Leaflet in R. While the leaflet package supports many options, the documentation is not the clearest and I had to do a bit of googling to customise the plot to my liking. This walkthrough documents the key features of the package which I find useful in generating choropleth overlays. Compared to the simple `tmap` approach documented in the previous post, creating a visualisation using leaflet gives more control over the final outcome. I will be covering two different kinds of display options (highlight on mouse over and on-click) as well as the use of layers. The post is an aggregation of materials from the official [Leaflet for R](https://rstudio.github.io/leaflet/) documentation page as well as a few other blogs.

```{r prelim, include=FALSE}
library(rgdal) #use readOGR to read in .shp files 
library(rgeos)
library(maptools)
library(leaflet)
library(dplyr)
library(raster)
library(reshape2)

GIS_path <- "C:/Users/Timothy Lin/Documents/Repo/sg-mapping/data/GIS"
data_path <- "C:/Users/Timothy Lin/Documents/Repo/website-hugo/datasets/SG_region_data_clean.rds"

sg_shape <- readOGR(dsn=GIS_path, layer="SingaporeMap_Polygon", verbose=FALSE)
sg_plan_2015 <- readOGR(dsn=GIS_path, layer="MP14_PLNG_AREA_WEB_PL", verbose=FALSE)

exclude <- c("PEDRA BRANCA", "JOHOR")
sg_shape_main <- sg_shape[(sg_shape$FOLDERPATH %in% c("Layers/Coastal_Outline")) &     !grepl(paste(exclude,collapse="|"), sg_shape$NAME),]
### Combine region mapping with actual Singapore map
sg <- raster::intersect(buffer(sg_plan_2015, dissolve=FALSE), as(sg_shape_main, 'SpatialPolygons'))
sg <- unionSpatialPolygons(sg, IDs=as.factor(sg$PLN_AREA_N))
sg <- SpatialPolygonsDataFrame(sg, sg_plan_2015@data, match.ID ="PLN_AREA_N")
sg <- rmapshaper::ms_simplify(sg, keep=0.05, keep_shapes=TRUE)
## sg <- gSimplify(sg, 20, topologyPreserve=TRUE)
### Append the data back
sg_data <- SpatialPolygonsDataFrame(sg, sg_plan_2015@data)
df <- readRDS(data_path)

SelectData <- function(df, name, variable){
  
  data_total <- df%>%
    filter(content==name & Level_1=="Total" & Level_2=="Total") %>%
    rename(total = Value) %>%
    dplyr:: select(Year, Level_3, total)
  
  data <- df%>%
    filter(content==name & Level_1!="Total") %>%
    left_join(data_total, by=c("Year", "Level_3")) %>%
    mutate(prop = Value/total *100,
           Level_3 = toupper(Level_3))
  
  if(length(unique(data$Level_2))==1){
    data_wide <- data %>%
      dplyr::select(Level_1, Level_3, get(variable), Year) %>%
      dcast(Level_3 ~ Level_1 + Year, value.var=variable)
    vec_names <- unique(data$Level_1)
    } else{
    data_wide <- data %>%
      dplyr::select(Level_1, Level_2, Level_3, get(variable), Year) %>%
      dcast(Level_3 ~ Level_1 + Level_2 + Year, value.var=variable)
    vec_names <- as.vector(outer(unique(data$Level_1), unique(data$Level_2), paste, sep="_"))
    }
  
  tryCatch(  
    for(i in 1:length(vec_names)){
      data_wide[,paste0(vec_names[i], "_diff")] <- 
        data_wide[,paste0(vec_names[i], "_2015")] - data_wide[,paste0(vec_names[i], "_2000")]
    }, 
    error = function(e) print("Err: Not all columns have data in 2015 and 2000"))
  return(data_wide)
  
}

religion_data <- SelectData(df, "resident_pop_religion", "prop")

for (i in c(2000,2010,2015)){
  religion_data[,paste0("Christianity_",i)] <- 
    religion_data[,paste0("Christianity Catholic_",i)] + 
    religion_data[,paste0("Christianity Other Christians_",i)]
}

religion_data$Christianity_diff <- religion_data$Christianity_2015 - religion_data$Christianity_2000

religion_map <- tmaptools::append_data(sg, religion_data, key.shp="PLN_AREA_N",key.data="Level_3")
```

### Initialising

I will be using a Singapore dataset consisting of the change in religious beliefs from 2000 to 2015, documented in the [previous post](/2017/09/10/examining-the-changes-in-religious-beliefs-part-2/). The file `religion_map` belongs to the `SpatialPolygonsDataFrame` class (though leaflet is also compatible with other classes of data). I have also used the `ms_simplify` function from the `rmapshaper` package to simplify the shapefile for web-plotting purposes.

First, we will need to change the projection of the shape file so that it uses a latitude/longitude system. 

```{r latlong}
proj4string(religion_map)
religion_map <- spTransform(religion_map, CRS("+proj=longlat +datum=WGS84"))
proj4string(religion_map)
```

Now we can initialise the leaflet file by choosing a basemap which the polygons would subsequently be projected onto. There are a variety of basemaps and a full range of choices can be seen in the following [link](http://leaflet-extras.github.io/leaflet-providers/preview/index.html).

```{r providertiles}
rawleafletmap <- leaflet() %>% 
  addProviderTiles("CartoDB.Positron",
                   options = tileOptions(minZoom=10, maxZoom=13))
```

The `addPolygons` function overlay the base map with our desired shapefile. In order to fill the shapes with the desired colours, we need to pass a vector containing the colour hex codes to the `fillColor` argument of the function. The `colorBin` function simplifies this task. In this example, I use the "RdYlGn" palette from RColorBrewer which has a nice divergent scheme that suits the data that is going to be presented. To make it easy to follow through the steps, I shall plot the change in Christianity share from 2000 to 2015 (`Christianity_diff`) for all the subsequent examples. 

```{r firstplot}
bins <- c(-20, -10, -5, 0, 5, 10, 20)
pal <- colorBin("RdYlGn", domain = religion_map$Christianity_diff, bins = bins)
leafletmap <- rawleafletmap %>%
  addPolygons(data=religion_map,
              fillColor = ~pal(Christianity_diff))
# The ~ sign is used to signify that the variable used in the argument comes from the data
leafletmap
```

### Highlight

In the subsequent plot I edit some options to make the choropleth look better and add an interactive mouse-over function. The text that is going to be displayed has to be formatted as a html code. The line styles and display options are mainly adopted from the official example which incidentally looks much better than the default thick blue lines. A legend can be included using the `addLegend` function.

```{r plotHighlight}
labels <- sprintf(
  "<strong>%s</strong><br/>Diff: %g ",
  religion_map$PLN_AREA_N, religion_map$Christianity_diff
) %>% lapply(htmltools::HTML)

leafletmap <- rawleafletmap %>%
  addPolygons(data=religion_map,
              fillColor = ~pal(Christianity_diff),
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              fillOpacity = 0.7,
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                dashArray = "",
                fillOpacity = 0.7,
                bringToFront = TRUE),
              label = labels,
              labelOptions = labelOptions(
                style = list("font-weight" = "normal", padding = "3px 8px"),
                textsize = "15px",
                direction = "auto"))

leafletmap %>% addLegend(pal = pal, values = religion_map$Christianity_diff, opacity = 0.7,
                         title = NULL, position= "bottomright")
```

### Popup

An alternative to the mouse over highlight function is to display the required information when a particular region is clicked. We can do this by passing the labels to the `popup` argument. I also selected another basemap, this time with colour, for additional variety.

```{r popup}
leafletmap <- leaflet() %>% 
  addProviderTiles("Esri.WorldStreetMap",
                   options = tileOptions(minZoom=10, maxZoom=13)) %>%
  addPolygons(data=religion_map,
              fillColor = ~pal(Christianity_diff),
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              fillOpacity = 0.7,
              popup = labels)
leafletmap
```

### Layers

Leaflet supports the plotting of multiple choropleth layers. This allows different information to be displayed depending on the choice of selection. To add layers, one simply assigns a particular `group` to an `addPolygons` code chunk and control the final output using the `addLayersControl` function. In the following example, I create an extra layer to visualise the change in Islam share over time.

```{r layers}
labels2 <- sprintf(
  "<strong>%s</strong><br/>Diff: %g ",
  religion_map$PLN_AREA_N, religion_map$Islam_diff
) %>% lapply(htmltools::HTML)

leafletmap <- leaflet() %>% 
  addProviderTiles("Esri.WorldStreetMap",
                   options = tileOptions(minZoom=10, maxZoom=13)) %>%
  addPolygons(data=religion_map,
              fillColor = ~pal(Christianity_diff),
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              fillOpacity = 0.7,
              popup = labels,
              group = "Christianity") %>%
  addPolygons(data=religion_map,
              fillColor = ~pal(Islam_diff),
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              fillOpacity = 0.7,
              popup = labels2,
              group = "Islam")

leafletmap %>% addLayersControl(c("Christianity", "Islam"),
   options = layersControlOptions(collapsed = FALSE))
```

### Multiple layers

The code is already getting quite long due to the repetition of colour and line options. What if we want to create multiple layers and minimise the clutter? One way to do that is to write a small wrapper function that repeats the `addPolygons` tasks. The `LeafletLayer` function in the code below is used to create the final plot which shows the change in the proportion of residents subscribing to a particular religion for 7 different groups. The function could probably be more generalised and accept other use inputs but it suits my needs perfectly fine.

```{r LayerFunction}
group <- c(names(religion_map)[40:45], "Christianity_diff")
labels <- vector("list", length(group))
fill <- vector("list", length(group))
for (i in 1:length(group)){
  fill[[i]] = pal(religion_map@data[,group[i]])
  labels[[i]] <- sprintf(
    "<strong>%s</strong><br/>Diff: %g ",
    religion_map$PLN_AREA_N, religion_map@data[,group[i]]
  ) %>% lapply(htmltools::HTML)
}

#' A wrapper for addPolygons function.
#' @param map raw leaflet basemap.
#' @param data dataset containing all the variables to be plotted
#' @param fillColor list of colours for each group
#' @param labels list of labels for each group
#' @param group vector of group names
#' @return leaflet file with the added polygon layers
LeafletLayer <- function(map, data, fillColor, labels, group){
  for (i in 1:length(group)){
  map <- addPolygons(map = map,
      data=data,
      fillColor = fill[[i]],
      weight = 2,
      opacity = 1,
      color = "white",
      dashArray = "3",
      fillOpacity = 0.7,
      group = group[i],
      highlight = highlightOptions(
        weight = 5,
        color = "#666",
        dashArray = "",
        fillOpacity = 0.7,
        bringToFront = TRUE),
      label = labels[[i]],
      labelOptions = labelOptions(
        style = list("font-weight" = "normal", padding = "3px 8px"),
          textsize = "15px",
          direction = "auto"))
  }
  map <- addLayersControl(map=map, baseGroups = group,
                          options = layersControlOptions(collapsed = FALSE))
}

map <- LeafletLayer(map=rawleafletmap, data=religion_map, fillColor=fill, labels=labels, group=gsub("_diff", "", group))
map
```

Hope you find this tutorial helpful and useful. It is actually quite simple to create interactive maps in R and maybe this will also inspire you to work on your own visualisation projects. 