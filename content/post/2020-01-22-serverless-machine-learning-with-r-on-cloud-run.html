---
title: Serverless Machine Learning with R on Cloud Run
author: Timothy Lin
date: '2020-01-22'
slug: serverless-machine-learning-with-r-on-cloud-run
categories: []
tags: ['notes', 'r', 'visualization', 'gcp', 'serverless']
subtitle: ''
---



<p>One of the main challenges that every data scientist face is model deployment. Unless you are one of the lucky few who has loads of data engineers to help you deploy a model, it‚Äôs really an issue in enterprise projects. I am not even implying that the model needs to be production ready but even a seemingly basic issue of making the model and insights accessible to business users is more of a hassle then it needs to be. There used to be 2 main ways of solving the problem:</p>
<ol style="list-style-type: decimal">
<li>Ad-hoc manual runs at every request</li>
<li>Hosting the code on a server and writing an API interface to make the results available</li>
</ol>
<p>These are two ends of the spectrum. Ad-hoc runs are just too tedious and clients typically demand for some self-serve interface but good luck trying to get a permanent server to host your code. Turns out there is a third way - the serverless way! AWS Lambdas and Google Cloud Platform Cloud Functions have really opened up a new way of serving results without having to manage any infrastructure. If you have access to the cloud, this is a very attractive option.</p>
<p>If you are from the javascript or python world you might have already used some of these tools. The problem with cloud functions is that it is restricted to particular environments. However, with the recent introduction of GCP‚Äôs <a href="https://cloud.google.com/run/docs/reference/container-contract">Cloud Run</a>, we are no longer limited by this problem. Cloud run allows custom docker images to be served on the cloud, opening up the serverless realm to many interesting possibilities. This means that R users can also finally have a way to develop and deploy serverless ML models!üéâ<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>This post documents some of my experience with cloud run and hopefully serves as a good reference template for anyone who might want to try it out. I take inspiration from two other sources, namely <a href="https://code.markedmondson.me/googleCloudRunner-intro/">Mark‚Äôs blog</a> and <a href="https://ericjinks.com/blog/2019/serverless-R-cloud-run/">Eric‚Äôs post</a>. Mark actually has a package on CRAN that automates some of the deployment work and Eric has a nice bit on continuous integration pipelines so do check it out.</p>
<p>This post is more of a practical guide with a real world machine learning application that an analyst might develop and wish to deploy, which I think makes the application a lot more concrete and useful. It‚Äôs also a really fun little side project.</p>
<p>If you are a coding person, you could skip the rest of the post and dive into the <a href="https://github.com/timlrx/serverless-ml">github code</a>, otherwise read on :)</p>
<div id="will-my-project-run-on-the-cloud-run" class="section level2">
<h2>Will My Project Run on the Cloud Run?</h2>
<p>Cloud run is not a panacea. Check out the <a href="https://cloud.google.com/run/docs/reference/container-contract">requirement specification</a> and <a href="https://cloud.google.com/run/quotas">limits</a> for more details but here are some limitations that you should be aware of.</p>
<ul>
<li>States are not persisted (if you want to persist them you need an external database)<br />
</li>
<li>The maximum memory limit is 2GB<br />
</li>
<li>The container must start a server within 4 minutes after receiving a request and it times out after 15 minutes</li>
</ul>
<p>This makes it well suited for short computations, but not tasks which might require lots of memory or are very CPU intensive. 15 minutes in reality is not too bad! You could probably run some regressions, decision trees, even solve a linear programming problem but maybe not train a neural network.</p>
</div>
<div id="twitter-project" class="section level2">
<h2>Twitter Project üê¶</h2>
<p><img src="/img/serverless/sentiment1.PNG" /></p>
<p>Here‚Äôs my fun serverless-ml weekend project: an application that analyzes the twitter-verse. I wanted to generate two plots: a graph which compares the frequency of tweets over time and another one which does a sentiment analysis on the tweets. As an added bonus, I decided to make it interactive - this means serving static plots as well as interactive plotly results.</p>
<p>The main package I used were: rtweet, dplyr, ggplot2, tidytext, tidyr and stringr. If you are new to tidytext, check out some of my previous posts such as this one way back in 2017 which analyzes <a href="https://www.timlrx.com/2017/06/24/thesis-thursday-4-analysing-recipes/">recipe books</a>.</p>
<p>rtweet provides a convenient api to collect users timeline information. You would need a twitter API account to get started. It‚Äôs a simple process and you can register for one here: <a href="https://developer.twitter.com/en/apply-for-access" class="uri">https://developer.twitter.com/en/apply-for-access</a>.</p>
<p>Take note of the four keys/tokens. They should be saved as an environment variable in your system.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> These four keys correspond to API_KEY, API_SECRET_KEY, ACCESS_TOKEN and ACCESS_SECRET in the tweet.R file and will be retrieved programmatically when needed.</p>
<p><img src="/img/serverless/twitter_api.PNG" /></p>
<div id="tweet.r" class="section level3">
<h3><a href="(https://github.com/timlrx/serverless-ml/blob/master/twitter-r/tweet.R)">Tweet.R</a></h3>
<p>Won‚Äôt go much into the data science code but you can check it out over <a href="https://github.com/timlrx/serverless-ml/blob/master/twitter-r/tweet.R">here</a>. The important part of it is that we are encapsulating each part as a function which we then call in the main api routing file (app.R).</p>
<p>For the sentiment analysis, we are counting the number of positive and negative words as matched by a dictionary.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> The lexical dictionary is from <a href="https://www.cs.uic.edu/~liub/FBS/sentiment-analysis.html">Bing Liu et al.</a>. Doesn‚Äôt this require at external database? Not really - external dependencies or data files are fine, as long as they are stateless. We can package it together with our docker file or in this case it comes installed with the tidytext package!</p>
</div>
<div id="app.r" class="section level3">
<h3><a href="https://github.com/timlrx/serverless-ml/blob/master/twitter-r/app.R">App.R</a></h3>
<p>This file contains the serving logic. We are using the <a href="https://www.rplumber.io/">plumber package</a> which allows us to create a REST API in R by decorating it in with some markup. You can specify query parameters by using a <code>#* @param</code> markup and specify the type of output to return such as <code>#* @png</code> for a static image or <code>#* @html</code> for html.</p>
<p>As an added bonus, there‚Äôs also an out of the box option to make htmlwidgets work (<code>#* @serializer htmlwidget</code>). This makes our serving plotly results really simple. I decided to create two paths for each plot, a static one as well as a plotly interactive result. So in total we have four paths:</p>
<ul>
<li>/frequency (ggplot)</li>
<li>/html/frequency (plotly)</li>
<li>/sentiment (ggplot)</li>
<li>/html/sentiment (plotly)</li>
</ul>
<p>The functions all accept two arguments: <code>n</code> - the number of tweets, and <code>users</code> which could be a comma separated list of user IDs which we will then query the twitter API via rtweet for the relevant information.</p>
</div>
<div id="server.r" class="section level3">
<h3><a href="https://github.com/timlrx/serverless-ml/blob/master/twitter-r/server.R">Server.R</a></h3>
<p>This is the bit of code that starts our plumber server. We infer the port as defined by an environment variable (PORT).</p>
<p>That‚Äôs it for the R code. Now you should have a working application which you can run locally from your computer. Next, we get into the grimy details of ML-ops üèÉ‚Äç‚ôÄ. This involves packaging our dependencies with docker and deploying it on cloud run.</p>
</div>
</div>
<div id="docker" class="section level2">
<h2>Docker</h2>
<p>Docker is a platform which packages different software, configurations and environments into containers which neatly encapsulate your application. The end user just needs to list out the installation steps to build the image which can subsequently be run on the docker platform üê≥.</p>
<p>To jump start the configuration, we build on top of the official <a href="https://hub.docker.com/_/r-base">r-base image</a>. It‚Äôs a Linux image and we need to install some additional dependencies to make the application work, namely libssl-dev for rtweet and pandoc for dealing with htmlwidgets. This forms the start of our <a href="https://github.com/timlrx/serverless-ml/blob/master/twitter-r/Dockerfile">Dockerfile</a>:</p>
<pre><code>FROM r-base
RUN apt-get update -qq &amp;&amp; apt-get install -y \
  git-core \
  libssl-dev \
  libcurl4-gnutls-dev \
  pandoc</code></pre>
<p>Next, we copy the scripts in our directory to the app directory in the container and install the necessary R libraries using the Rscript function:</p>
<pre><code>WORKDIR /usr/src/app

# Copy local code to the container image.
COPY . .

# Install any R packages
RUN Rscript -e &quot;install.packages(&#39;plumber&#39;)&quot;
RUN Rscript -e &quot;install.packages(c(&#39;rtweet&#39;, &#39;dplyr&#39;, &#39;ggplot2&#39;, &#39;plotly&#39;, &#39;tidytext&#39;, &#39;tidyr&#39;, &#39;stringr&#39;))&quot;</code></pre>
<p>We expose port 8000 (this is more for documentation) and run the server when the container is launched:</p>
<pre><code>EXPOSE 8000

# Run the web service on container startup.
CMD [ &quot;Rscript&quot;, &quot;server.R&quot;]</code></pre>
<p>let‚Äôs build the docker image and give it a run:</p>
<pre><code>docker build -t ${IMAGE} .
docker run -p 8000:8000 -e PORT=8000 -e API_KEY -e API_SECRET_KEY -e ACCESS_TOKEN -e ACCESS_SECRET ${IMAGE}</code></pre>
<p><code>${IMAGE}</code> here represents the name which you can assign to the image. Remember the environment variables that we need for the application? Port for plumber and the API keys to access twitter API? We pass it to the container when we are running it. Note: The build process is quite long, with the image being 1.22GB big.<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></p>
<p>If the image runs successfully, you should be able to access the routes on your browser. Now, we can take it from your local machine to the web!</p>
</div>
<div id="cloud-run" class="section level2">
<h2>Cloud Run</h2>
<p>You can use my <a href="https://github.com/timlrx/serverless-ml/blob/master/twitter-r/deploy.sh">deploy.sh</a> script as a guide on how to build and deploy your image. Before doing so, I recommend that you assign the Cloud Run Admin role to the account or user you are running the script in order for it to be deployed correctly. You can do it from the <a href="https://console.cloud.google.com/iam-admin">IAM panel</a> within GCP.</p>
<p>In the script, I retrieved the project ID programmatically, but feel free to substitute it with your GCP project. All the script does is to upload the local docker image to Google‚Äôs container repository and run cloud run to deploy the image from the repository:</p>
<pre><code>gcloud alpha run deploy \
    --image=&quot;gcr.io/${PROJECT_ID}/${IMAGE}:1.0.0&quot; \
    --region=&quot;us-central1&quot; \
    --platform managed \
    --memory=512Mi \
    --port=8000 \
    --set-env-vars API_KEY=${API_KEY},API_SECRET_KEY=${API_SECRET_KEY},ACCESS_TOKEN=${ACCESS_TOKEN},ACCESS_SECRET=${ACCESS_SECRET} \
    --allow-unauthenticated</code></pre>
<p>We add an <code>allow-unauthenticated</code> to allow public traffic and increase the memory as the default was too low. You can start with the default 256MB first but if you encounter any errors, do check the cloud run logs which is very useful for debugging any errors. If all goes well, you should be greeted with an image like this:</p>
<p><img src="/img/serverless/cloud_run_success.PNG" /></p>
<p>Our twitter project is now successfully hosted on Cloud Run!</p>
</div>
<div id="test-it-out" class="section level2">
<h2>Test it out</h2>
<p>Here‚Äôs the fun part - try it out and visualize and analyse live twitter data!</p>
<p>You can try out my hosted cloud run with one of the 4 endpoints listed above: <a href="https://twitter-r-cvdvxo3vga-uc.a.run.app/" class="uri">https://twitter-r-cvdvxo3vga-uc.a.run.app/</a></p>
<p>Some fun examples!</p>
<div id="frequency-of-obama-tweets" class="section level3">
<h3>Frequency of Obama tweets</h3>
<p>The most followed person on Twitter with 112 million followers does not actually tweet too frequently ü§î:<br />
<a href="https://twitter-r-cvdvxo3vga-uc.a.run.app/frequency?n=500&amp;users=BarackObama" class="uri">https://twitter-r-cvdvxo3vga-uc.a.run.app/frequency?n=500&amp;users=BarackObama</a></p>
<p><img src="/img/serverless/freq_obama_tweets.PNG" /></p>
</div>
<div id="sentiment-analysis-comparison-between-bbcworld-and-realdonaldtrump" class="section level3">
<h3>Sentiment analysis comparison between BBCworld and realDonaldTrump</h3>
<p>Sad!<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a><br />
<a href="https://twitter-r-cvdvxo3vga-uc.a.run.app/sentiment?n=1000&amp;users=BBCWorld,realDonaldTrump" class="uri">https://twitter-r-cvdvxo3vga-uc.a.run.app/sentiment?n=1000&amp;users=BBCWorld,realDonaldTrump</a></p>
<p><img src="/img/serverless/sentiment1.PNG" /></p>
</div>
<div id="what-do-politicians-and-entertainers-have-in-common" class="section level3">
<h3>What do politicians and entertainers have in common?</h3>
<p>They are overwhelmingly positive (here we use our plotly html endpoint)<br />
<a href="https://twitter-r-cvdvxo3vga-uc.a.run.app/html/sentiment?n=500&amp;users=narendramodi,TheEllenShow" class="uri">https://twitter-r-cvdvxo3vga-uc.a.run.app/html/sentiment?n=500&amp;users=narendramodi,TheEllenShow</a></p>
<p><img src="/img/serverless/sentiment2.PNG" /></p>
</div>
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<p>That‚Äôs it for this serverless + R tutorial. Hope you managed to learn something useful or at the very least find the twitter analysis interesting üòÉ. The nice part about having this application running is that you can analyze the real-time twitter frequency or sentiment plots with whatever account you choose (even your own).<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There are some very nice benefits of using a serverless stack as well such as per second billing, automatically scalable containers which makes it a perfect fit to deploy a hobby project.<a href="#fnref1" class="footnote-back">‚Ü©</a></p></li>
<li id="fn2"><p>If you are in R, you can call <code>Sys.setenv()</code> or just export it using the CLI<a href="#fnref2" class="footnote-back">‚Ü©</a></p></li>
<li id="fn3"><p><a href="https://www.tidytextmining.com/sentiment.html" class="uri">https://www.tidytextmining.com/sentiment.html</a><a href="#fnref3" class="footnote-back">‚Ü©</a></p></li>
<li id="fn4"><p>I took about 15 minutes to build the image. That‚Äôs one of the downsides of R - it‚Äôs really convenient for analyzing data but not really friendly for production.<a href="#fnref4" class="footnote-back">‚Ü©</a></p></li>
<li id="fn5"><p>There are some issues scraping data from realDonaldTrump (<a href="https://github.com/ropensci/rtweet/issues/382" class="uri">https://github.com/ropensci/rtweet/issues/382</a>)<a href="#fnref5" class="footnote-back">‚Ü©</a></p></li>
<li id="fn6"><p>I will keep it up and running as long as I can as long as the usage does not suddenly spike up and exceed the free tier limit<a href="#fnref6" class="footnote-back">‚Ü©</a></p></li>
</ol>
</div>
